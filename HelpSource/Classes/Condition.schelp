CLASS::Condition
categories::Scheduling
summary::Block the execution of a thread

CLASSMETHODS::

method::new
Create a new instance, set the strong::test:: variable.

INSTANCEMETHODS::

method::test
Answer whether the condition will block or not (boolean).

method::wait
Wait until the condition is true and signalled. This only works in a Routine. This method yields a symbol (\hang), so that the clock doesn't reschedule the Routine.
code::
c = Condition(false); fork { 0.5.wait; "started ...".postln; c.wait;  "... and finished.".postln };
c.test = true;
c.signal;
::

method::hang
Wait for strong::value:: time, regardless of test. This only works in a Routine. This method yields a symbol (\hang), so that the clock doesn't reschedule the Routine.
code::
c = Condition.new; fork { 0.5.wait; "started ...".postln; c.hang;  "... and finished.".postln };
c.unhang;
::

method::timeoutAfter
Prepares a time limit for this thread to be re-awakened after waiting or hanging on a Condition. If a timeout is set, there are two possible outcomes: A. The condition will signal successfully (or unhang) emphasis::before:: the timeout expires, and the thread will resume (without firing a timeout action); or B. The timeout will expire, and the thread will resume after that number of beats. The code::action:: function can set a flag so that the calling thread knows it's resuming due to a timeout. (If no timeout is set, then the thread may hang indefinitely if the condition fails to be met.)

Call code::timeoutAfter:: immediately before calling code::wait:: or code::hang::. The timeout period begins at the moment of calling code::timeoutAfter::.

argument::timeout
Number of clock beats to wait before timing out.

argument::action
A function to execute only in case the timeout expires. The function will not execute for a successful signal or unhang.

method::signal
If link::#-test:: is true, reschedule blocked threads.

method::unhang
Resume threads.

EXAMPLES::

code::
(
c = Condition.new(false);

Routine {
	1.wait;
	"waited for 1 second".postln;
	1.wait;
	"waited for another second, now waiting for you ... ".postln;
	c.wait;
	"the condition has stopped waiting.".postln;
	1.wait;
	"waited for another second".postln;
	"waiting for you ... ".postln;
		c.test = false;
		c.wait;
	"the condition has stopped waiting.".postln;
	1.wait;
	"the end".postln;
}.play;
)

// continue
(
c.test = true;
c.signal;
)

// a typical use is a routine that can pause under certain conditions:
(
c = Condition.new;
fork { loop { 1.wait; "going".postln; c.wait } };
)
c.test = true; c.signal;
c.test = false;
::

code::
// the same, using hang

(
c = Condition.new;

Routine {
	1.wait;
	"waited for 1 second".postln;
	1.wait;
	"waited for another second, now waiting for you ... ".postln;
	c.hang;
	"the condition has stopped waiting.".postln;
	1.wait;
	"waited for another second".postln;
	"waiting for you ... ".postln;
	c.hang;
	"the condition has stopped waiting.".postln;
}.play;
)

// continue
c.unhang;
::

Timeout limits: About half the time, the synth will run longer than 1.0 second and the condition will time out.

code::
(
s.waitForBoot {
	var cond = Condition.new;
	
	var node = {
		var freq = XLine.kr(1, 2, rrand(0.5, 1.5), doneAction: 2);
		SinOsc.ar(freq, 0, 0.1).dup
	}.play;
	
	var endResp = OSCFunc({ |msg|
		"Synth ended on time".postln;
		endResp.free;
		cond.unhang;
	}, '/n_end', s.addr, argTemplate: [node.nodeID]);

	// here: cond.timeoutAfter().hang (or wait)
	cond.timeoutAfter(1.0, {
		endResp.free;
		"Reached timeout; synth hasn't ended".postln;
	}).hang;
	
	"Resumed thread".postln;
};
)
::

Waiting for Synths to end (waitForFree) uses a Condition implicitly:
code::
(
SynthDef(\help, { |out|
	var mod = LFNoise2.kr(ExpRand(0.5, 2)) * 0.5;
	var snd = mod * Blip.ar(Rand(200, 800) * (mod + 1));
	Out.ar(out, snd);
	FreeSelf.kr(mod < 0); // free the synth when amplitude goes below 0.
}).add;
)

(
fork {
	10.do {
		"started a synth".postln;
		Synth(\help).waitForFree;
		"This one ended. Wait a second,  I will start the next one.".postln;
		1.wait;
	};
	"This is it.".postln;
}
);
::
